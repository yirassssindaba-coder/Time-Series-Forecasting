<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Combined Report — Image + YoY Editor</title>
  <meta name="description" content="Upload image left, create YoY chart right, edit (overlay) chart onto uploaded image and save edited image. If no image present, Edit will create a new base image to draw overlay." />
  <style>
    :root{
      --bg: linear-gradient(180deg,#f8fbff,#f2f7ff);
      --muted: #6b7280;
      --accent: #6366f1;
      --card: #fff;
      --control-gap: 10px;
      --btn-height: 36px;
    }
    html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,Roboto,Arial;color:#071032}
    .container{max-width:1200px;margin:18px auto;display:grid;grid-template-columns:640px 1fr;gap:18px}
    .card{background:var(--card);padding:14px;border-radius:12px;box-shadow:0 12px 30px rgba(15,23,42,0.06);border:1px solid rgba(15,23,42,0.04)}
    h2{margin:0 0 6px 0}
    .small{font-size:13px;color:var(--muted);line-height:1.35}
    .img-wrap{height:560px;border-radius:10px;background:#fff;border:1px solid rgba(6,182,212,0.04);overflow:auto;display:flex;align-items:center;justify-content:center;padding:12px}
    .controls{display:flex;flex-wrap:wrap;align-items:center;gap:var(--control-gap);margin-top:12px}
    .file-control{display:flex;align-items:center;gap:8px}
    input[type=file]{height:var(--btn-height)}
    .btn{height:var(--btn-height);padding:0 12px;border-radius:8px;border:1px solid rgba(15,23,42,0.06);background:#fff;cursor:pointer}
    .btn.primary{background:var(--accent);color:#fff;border:none;box-shadow:0 4px 10px rgba(99,102,241,0.12)}
    .btn.ghost{background:#fff}
    .btn-group{display:flex;gap:8px;align-items:center}
    .params{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-top:12px}
    label{font-size:13px}
    input[type=range]{vertical-align:middle}
    input[type=number]{padding:6px;border-radius:6px;border:1px solid #e6edf7;width:80px}
    select{padding:6px;border-radius:6px;border:1px solid #e6edf7}
    .right-col .card{margin-bottom:12px}
    .chart-canvas{background:#fff;border-radius:8px;padding:8px}
    table{width:100%;border-collapse:collapse;margin-top:12px}
    table th, table td{padding:8px;border-bottom:1px solid #f1f5f9;text-align:left}
    td.editable{background:#fff7e6}
    td.actions{width:160px;text-align:center}
    @media(max-width:980px){
      .container{grid-template-columns:1fr}
      .img-wrap{height:320px}
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>
<body>
  <div class="container">
    <section class="card">
      <h2>Plot (PNG / JPG)</h2>
      <div class="small">Upload pipeline PNG/JPG. Use "Edit PNG" to apply chart overlay — the left image will be edited in-place. If no image exists, Edit will create a new white canvas and draw the overlay. Use "Revert" to restore uploaded original, "Delete" to remove uploaded/edited image, and "Save Edited" to download the edited image.</div>

      <div class="controls" style="margin-top:16px">
        <div class="file-control">
          <input id="plotImageFile" type="file" accept="image/png,image/jpeg" />
          <div id="leftInfo" style="font-size:13px;color:var(--muted);margin-left:6px">Loaded image: —</div>
        </div>

        <div class="btn-group" style="margin-left:auto">
          <button id="editLeftPng" class="btn primary">Edit PNG</button>
          <button id="revertLeftPng" class="btn">Revert</button>
          <button id="deleteLeftPng" class="btn">Delete</button>
          <button id="saveEditedPng" class="btn">Save Edited</button>
        </div>
      </div>

      <div class="img-wrap" id="leftCanvasWrap" style="margin-top:14px">
        <div class="small">No image loaded.</div>
      </div>

      <div class="params">
        <label>Opacity: <input id="overlayOpacity" type="range" min="0" max="1" step="0.05" value="0.9" /></label>
        <label>Scale (%): <input id="overlayScale" type="number" value="30" />%</label>
        <label>Position:
          <select id="overlayPosition">
            <option value="top-right">Top-right</option>
            <option value="top-left">Top-left</option>
            <option value="bottom-right">Bottom-right</option>
            <option value="bottom-left">Bottom-left</option>
            <option value="center">Center</option>
          </select>
        </label>
      </div>
    </section>

    <aside class="card right-col">
      <h2>Analisis Perbandingan Waktu — YoY Editor</h2>
      <div class="small">Unggah CSV (date,value) atau masukkan data manual. Klik Generate untuk membuat Chart (Chart.js). Setelah generate, gunakan "Edit PNG" untuk menerapkan overlay ke gambar kiri (atau membuat base baru jika belum ada), lalu "Save Edited" untuk menyimpan hasil.</div>

      <div class="card" style="margin-top:12px">
        <label>CSV (date,value): <input id="csvFile" type="file" accept=".csv" /></label>
        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
          <input id="manualYear" type="number" placeholder="Year" style="width:90px" />
          <input id="manualValue" type="number" placeholder="Value" style="width:120px" />
          <input id="manualCount" type="number" placeholder="Count" style="width:90px" min="0" value="1" />
          <button id="addManualBtn" class="btn">Tambah</button>
        </div>

        <div style="margin-top:12px;display:flex;gap:8px;align-items:center">
          <label>Rentang tahun:</label>
          <input id="yearFrom" type="number" value="2019" style="width:100px" />
          <input id="yearTo" type="number" value="2024" style="width:100px" />
        </div>

        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
          <label>Mode periode:
            <select id="periodMode"><option value="fullYear">Full year</option><option value="monthDayRange">Month-day range</option><option value="customDates">Custom dates</option></select>
          </label>
          <label>Agregasi:
            <select id="aggMode"><option value="avg">AVG</option><option value="sum">SUM</option><option value="last">LAST</option></select>
          </label>
        </div>

        <div style="margin-top:12px;display:flex;gap:8px">
          <button id="generateBtn" class="btn primary">Generate</button>
          <button id="exportCsvBtn" class="btn">Export CSV</button>
          <button id="downloadIpynb" class="btn">Download .ipynb</button>
        </div>
      </div>

      <div class="card" style="margin-top:12px">
        <strong>Hasil & Visualisasi</strong>
        <div style="margin-top:8px" class="chart-canvas">
          <canvas id="chartCanvas" width="520" height="260"></canvas>
        </div>

        <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
          <label style="font-size:13px"><input id="overlayIfImage" type="checkbox" checked /> Overlay ke left image</label>
          <button id="downloadChartPng" class="btn" style="margin-left:auto">Save Chart PNG</button>
          <button id="saveTableCsv" class="btn" style="margin-left:8px">Save Table CSV</button>
        </div>

        <table id="resultTable" style="margin-top:12px;display:none">
          <thead><tr><th>Year</th><th>Value</th><th>Count</th><th>Diff</th><th>%</th><th>Aksi</th></tr></thead>
          <tbody></tbody>
        </table>

        <div style="margin-top:12px">
          <strong>Notebook preview</strong>
          <pre id="notebookPreview" style="height:120px;background:#0b1220;color:#e6eef8;padding:8px;border-radius:6px;overflow:auto">Notebook preview will appear here.</pre>
        </div>
      </div>
    </aside>
  </div>

<script>
/* --- Helpers --- */
function parseCSV(text){
  const lines = text.replace(/\r\n/g,'\n').split('\n').filter(l=>l.trim()!=='');
  if(!lines.length) return {header:[], rows:[]};
  const header = lines[0].split(',').map(h=>h.trim());
  const rows = lines.slice(1).map(l=>l.split(',').map(c=>c.trim()));
  return {header, rows};
}
function toDate(s){
  if(!s) return null;
  const d = Date.parse(s);
  if(!isNaN(d)) return new Date(d);
  const m = s && s.match(/^(\d{1,2})[\/\-\.\s](\d{1,2})[\/\-\.\s](\d{2,4})$/);
  if(m){ let a=parseInt(m[1],10), b=parseInt(m[2],10)-1, c=parseInt(m[3],10); if(c<100) c+=2000; return new Date(c,b,a); }
  return null;
}
function fmtNum(v){ return (v===null||v===undefined) ? "-" : Number(v).toLocaleString('en-US',{maximumFractionDigits:2}); }

/* --- Elements --- */
const plotImageFile = document.getElementById('plotImageFile');
const leftCanvasWrap = document.getElementById('leftCanvasWrap');
const leftInfo = document.getElementById('leftInfo');
const editLeftPng = document.getElementById('editLeftPng');
const revertLeftPng = document.getElementById('revertLeftPng');
const deleteLeftPng = document.getElementById('deleteLeftPng');
const saveEditedPng = document.getElementById('saveEditedPng');

const csvFile = document.getElementById('csvFile');
const manualYear = document.getElementById('manualYear');
const manualValue = document.getElementById('manualValue');
const manualCount = document.getElementById('manualCount');
const addManualBtn = document.getElementById('addManualBtn');

const yearFrom = document.getElementById('yearFrom');
const yearTo = document.getElementById('yearTo');
const periodMode = document.getElementById('periodMode');
const aggMode = document.getElementById('aggMode');
const generateBtn = document.getElementById('generateBtn');
const exportCsvBtn = document.getElementById('exportCsvBtn');
const downloadIpynbBtn = document.getElementById('downloadIpynb');

const chartCanvas = document.getElementById('chartCanvas');
const downloadChartPng = document.getElementById('downloadChartPng');
const saveTableCsv = document.getElementById('saveTableCsv');
const overlayIfImage = document.getElementById('overlayIfImage');
const overlayOpacity = document.getElementById('overlayOpacity');
const overlayScale = document.getElementById('overlayScale');
const overlayPosition = document.getElementById('overlayPosition');

const resultTable = document.getElementById('resultTable');
const resultTbody = resultTable.querySelector('tbody');
const notebookPreview = document.getElementById('notebookPreview');

let rawData = []; // array of {date, value}
let manualData = {}; // year => { value: number, count: number }
let chart = null;

/* LEFT: image handlers unchanged */
plotImageFile.addEventListener('change', e=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  leftCanvasWrap.innerHTML = '';
  leftInfo.textContent = "Loading image...";
  const reader = new FileReader();
  reader.onload = function(ev){
    const dataUrl = ev.target.result;
    const img = document.createElement('img');
    img.style.maxWidth = "100%";
    img.style.maxHeight = "100%";
    img.src = dataUrl;
    img.dataset.original = dataUrl;
    img.dataset.filename = f.name;
    delete img.dataset.edited;
    leftCanvasWrap.appendChild(img);
    leftInfo.textContent = `Loaded image: ${f.name}`;
  };
  reader.readAsDataURL(f);
});
deleteLeftPng.addEventListener('click', ()=>{ leftCanvasWrap.innerHTML = '<div class="small">No image loaded.</div>'; leftInfo.textContent = "Loaded image: —"; });
revertLeftPng.addEventListener('click', ()=>{ const img = leftCanvasWrap.querySelector('img'); if(!img){ alert('No image loaded'); return; } if(img.dataset && img.dataset.original){ img.src = img.dataset.original; leftInfo.textContent = `Reverted to original: ${img.dataset.filename || 'uploaded'}`; delete img.dataset.edited; } else { alert('Original image not available to revert.'); }});
saveEditedPng.addEventListener('click', ()=>{ const img = leftCanvasWrap.querySelector('img'); if(!img || !img.src){ alert('No image loaded'); return; } const dataUrl = img.dataset.edited || img.src; const originalName = (img.dataset && img.dataset.filename) ? img.dataset.filename.replace(/\.[^/.]+$/, "") : "left_image"; const suggested = `${originalName}-edited.png`; const a = document.createElement('a'); a.href = dataUrl; a.download = suggested; document.body.appendChild(a); a.click(); a.remove(); });

/* CSV import -> rawData unchanged */
csvFile.addEventListener('change', e=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const r = new FileReader();
  r.onload = ()=>{
    const parsed = parseCSV(r.result);
    const header = parsed.header, rows = parsed.rows;
    let dateIdx=-1, valIdx=-1;
    for(let i=0;i<header.length;i++){
      let dcount=0,ncount=0;
      for(let j=0;j<Math.min(rows.length,80); j++){
        const v = rows[j][i]||"";
        if(toDate(v)) dcount++;
        if(v!=="" && !isNaN(parseFloat(v))) ncount++;
      }
      if(dcount >= Math.max(1, Math.floor(rows.length*0.25))) dateIdx = i;
      if(ncount >= Math.max(1, Math.floor(rows.length*0.25))) valIdx = i;
    }
    if(dateIdx === -1) dateIdx = 0;
    if(valIdx === -1) valIdx = (header.length>1?1:0);
    rawData = [];
    rows.forEach(rw=>{
      const d = toDate(rw[dateIdx]);
      const v = parseFloat(rw[valIdx]);
      if(d && !isNaN(v)) rawData.push({date:d, value:v});
    });
    rawData.sort((a,b)=>a.date - b.date);
    notebookPreview.textContent = rawData.slice(0,50).map(r=>`${r.date.toISOString().slice(0,10)},${r.value}`).join('\n') || "No valid rows";
    alert(`CSV loaded — ${rawData.length} valid rows`);
  };
  r.readAsText(f);
});

/* Add manual row (Year/Value/Count) -> store in manualData as {value,count} */
addManualBtn.addEventListener('click', ()=>{
  const y = parseInt(manualYear.value,10);
  const v = manualValue.value === '' ? null : parseFloat(manualValue.value);
  const c = manualCount.value === '' ? 1 : parseInt(manualCount.value,10);
  if(isNaN(y) || (v===null || isNaN(v)) || isNaN(c) || c < 0){ alert('Masukkan Year, Value, dan Count yang valid'); return; }
  manualData[y] = { value: v, count: c };
  manualYear.value=''; manualValue.value=''; manualCount.value='1';
  alert('Manual row added');
});

/* Compute YoY now respects manualData entries with counts:
   - if useManual (manualData exists & rawData empty), for each year:
     - if agg == "avg": value_for_series = manual.value / manual.count (if count>0)
     - if agg == "sum": value_for_series = manual.value
     - if agg == "last": value_for_series = manual.value
   The "count" column is used as informational / to compute AVG when user provides aggregated value.
*/
function computeYoY(fromYear, toYear, mode, agg){
  const results = [];
  const useManual = (Object.keys(manualData).length > 0 && rawData.length === 0);
  for(let y=fromYear;y<=toYear;y++){
    let start = new Date(y,0,1), end = new Date(y,11,31,23,59,59);
    if(mode === 'monthDayRange'){
      const s = document.getElementById('startMMDD') ? document.getElementById('startMMDD').value || '01-01' : '01-01';
      const e = document.getElementById('endMMDD') ? document.getElementById('endMMDD').value || '12-31' : '12-31';
      const sp = s.split('-'), ep = e.split('-');
      start = new Date(y, parseInt(sp[0],10)-1, parseInt(sp[1],10));
      end = new Date(y, parseInt(ep[0],10)-1, parseInt(ep[1],10), 23,59,59);
    } else if(mode === 'customDates'){
      const stElem = document.getElementById('startTemplate'), enElem = document.getElementById('endTemplate');
      const st = stElem ? stElem.value : null;
      const en = enElem ? enElem.value : null;
      if(st && en){
        const sdate = new Date(st), edate = new Date(en);
        start = new Date(y, sdate.getMonth(), sdate.getDate());
        end = new Date(y, edate.getMonth(), edate.getDate(), 23,59,59);
      }
    }
    let vals = [];
    let count = 0;
    if(useManual){
      const entry = manualData[y];
      if(entry !== undefined && entry.value != null){
        // interpret manual entry according to agg
        if(agg === 'sum' || agg === 'last'){
          vals = [entry.value];
          count = entry.count || 1;
        } else { // avg
          // if user provided aggregated sum in entry.value with count entry.count,
          // compute average value_for_series = entry.value / count
          if(entry.count && entry.count > 0){
            vals = [entry.value / entry.count];
            count = entry.count;
          } else {
            vals = [entry.value];
            count = 1;
          }
        }
      } else {
        vals = [];
        count = 0;
      }
    } else {
      const filtered = rawData.filter(r=> r.date>=start && r.date<=end).map(r=>r.value);
      vals = filtered;
      count = filtered.length;
    }
    let value = null;
    if(vals.length === 0) value = null;
    else if(agg === 'sum') value = vals.reduce((a,b)=>a+b,0);
    else if(agg === 'last') value = vals[vals.length-1];
    else value = vals.reduce((a,b)=>a+b,0)/vals.length;
    results.push({year:y, value:value, count:count});
  }
  for(let i=0;i<results.length;i++){
    const cur=results[i], prev=i>0?results[i-1]:null;
    if(prev && cur.value!=null && prev.value!=null){ cur.diff = cur.value - prev.value; cur.pct = prev.value!==0 ? (cur.diff/Math.abs(prev.value))*100 : null; } else { cur.diff=null; cur.pct=null; }
  }
  return results;
}

/* Render results: includes Count as editable column and Edit/Save per-row plus Hapus */
function renderResults(results){
  resultTbody.innerHTML = '';
  const labels = [], data = [];
  results.forEach(r=>{
    const tr = document.createElement('tr');

    const yearTd = document.createElement('td'); yearTd.className = 'year'; yearTd.contentEditable = 'false'; yearTd.innerText = r.year;
    const valueTd = document.createElement('td'); valueTd.className = 'value'; valueTd.contentEditable = 'false'; valueTd.innerText = r.value===null? '' : r.value;
    const countTd = document.createElement('td'); countTd.className = 'count'; countTd.contentEditable = 'false'; countTd.innerText = (r.count===null || r.count===undefined) ? '' : String(r.count);

    const diffTd = document.createElement('td'); diffTd.className = 'diff'; diffTd.contentEditable = 'false'; diffTd.innerText = r.diff===null? '-' : fmtNum(r.diff);
    const pctTd = document.createElement('td'); pctTd.className = 'pct'; pctTd.contentEditable = 'false'; pctTd.innerText = r.pct===null? '-' : (r.pct.toFixed(2)+'%');

    const actionTd = document.createElement('td'); actionTd.className='actions';
    const editBtn = document.createElement('button'); editBtn.className='btn'; editBtn.innerText='Edit';
    const delBtn = document.createElement('button'); delBtn.className='btn'; delBtn.style.marginLeft='6px'; delBtn.innerText='Hapus';
    actionTd.appendChild(editBtn); actionTd.appendChild(delBtn);

    // Edit toggle
    editBtn.addEventListener('click', ()=>{
      const editing = tr.dataset.editing === 'true';
      if(!editing){
        tr.dataset.editing = 'true';
        tr.dataset.origDiff = diffTd.innerText;
        tr.dataset.origPct = pctTd.innerText;
        yearTd.contentEditable = 'true';
        valueTd.contentEditable = 'true';
        countTd.contentEditable = 'true';
        diffTd.contentEditable = 'true';
        pctTd.contentEditable = 'true';
        editBtn.innerText = 'Save';
        valueTd.focus();
      } else {
        // Save
        yearTd.contentEditable = 'false';
        valueTd.contentEditable = 'false';
        countTd.contentEditable = 'false';
        diffTd.contentEditable = 'false';
        pctTd.contentEditable = 'false';
        // If user changed diff/pct manually, set manual flag
        if(diffTd.innerText.trim() !== (tr.dataset.origDiff || '') || pctTd.innerText.trim() !== (tr.dataset.origPct || '')){
          tr.dataset.manual = 'true';
        }
        delete tr.dataset.editing;
        editBtn.innerText = 'Edit';
        // Update manualData mapping if rawData not used
        const y = parseInt(yearTd.innerText.trim(),10);
        const vtxt = valueTd.innerText.trim();
        const ctxt = countTd.innerText.trim();
        const v = vtxt === '' ? null : parseFloat(vtxt);
        const c = ctxt === '' ? 0 : parseInt(ctxt,10);
        if(!isNaN(y)){
          if(v === null || isNaN(v)){
            delete manualData[y];
          } else {
            manualData[y] = { value: v, count: (isNaN(c)? 0 : c) };
          }
        }
        recalcFromTable();
      }
    });

    // Delete
    delBtn.addEventListener('click', ()=>{
      const y = parseInt(yearTd.innerText.trim(),10);
      if(!isNaN(y) && manualData[y] !== undefined){
        delete manualData[y];
      }
      tr.remove();
      recalcFromTable();
    });

    // Blur handlers to update manualData/count on inline edits (when not in edit mode this won't trigger changes)
    valueTd.addEventListener('blur', ()=> {
      const y = parseInt(yearTd.innerText.trim(),10);
      const vtxt = valueTd.innerText.trim();
      const v = vtxt === '' ? null : parseFloat(vtxt);
      if(!isNaN(y)){
        const existing = manualData[y] || { value: null, count: 0 };
        if(v === null || isNaN(v)){
          delete manualData[y];
        } else {
          existing.value = v;
          existing.count = existing.count || 1;
          manualData[y] = existing;
        }
      }
      recalcFromTable();
    });
    countTd.addEventListener('blur', ()=> {
      const y = parseInt(yearTd.innerText.trim(),10);
      const ctxt = countTd.innerText.trim();
      const c = ctxt === '' ? 0 : parseInt(ctxt,10);
      if(!isNaN(y)){
        const existing = manualData[y] || { value: null, count: 0 };
        existing.count = isNaN(c) ? 0 : c;
        if(existing.value === null || existing.value === undefined){
          // keep but count updated
          manualData[y] = existing;
        } else {
          manualData[y] = existing;
        }
      }
      recalcFromTable();
    });
    yearTd.addEventListener('blur', ()=> recalcFromTable());

    tr.appendChild(yearTd);
    tr.appendChild(valueTd);
    tr.appendChild(countTd);
    tr.appendChild(diffTd);
    tr.appendChild(pctTd);
    tr.appendChild(actionTd);

    resultTbody.appendChild(tr);

    labels.push(String(r.year)); data.push(r.value===null?NaN:r.value);
  });

  resultTable.style.display = results.length ? 'table' : 'none';
  if(chart) try{ chart.destroy(); }catch(e){}
  const ctx = chartCanvas.getContext('2d');
  chart = new Chart(ctx, {
    type: 'line',
    data: { labels, datasets:[{ label:'Value', data, borderColor:'rgba(99,102,241,1)', backgroundColor:'rgba(99,102,241,0.12)', fill:true, tension:0.25 }] },
    options: { responsive:true, plugins:{legend:{display:false}}, scales:{ y:{beginAtZero:false} } }
  });
  notebookPreview.textContent = "YoY summary\n" + results.map(r=>`${r.year}, value=${r.value===null?'-':r.value}, count=${r.count}`).join('\n');
}

/* recalcFromTable updated to respect manualData and editable Count */
function recalcFromTable(){
  const trs = Array.from(resultTbody.querySelectorAll('tr'));
  // Build array of rows with year/value/count
  const rows = trs.map(tr=>{
    const y = parseInt(tr.querySelector('.year').innerText.trim(),10);
    const vtxt = tr.querySelector('.value').innerText.trim();
    const ctxt = tr.querySelector('.count').innerText.trim();
    const v = vtxt === '' ? null : parseFloat(vtxt);
    const c = ctxt === '' ? 0 : parseInt(ctxt,10);
    return { year: y, value: (isNaN(v)? null: v), count: (isNaN(c)? 0: c), tr: tr };
  }).filter(r=> !isNaN(r.year));
  rows.sort((a,b)=> a.year - b.year);

  // Update manualData mapping from table where relevant:
  rows.forEach(r=>{
    if(r.value !== null){
      manualData[r.year] = { value: r.value, count: r.count || 0 };
    } else {
      if(manualData[r.year] && (manualData[r.year].value === null || manualData[r.year].value === undefined)) {
        delete manualData[r.year];
      }
    }
  });

  // Now compute diffs/pct skipping rows flagged manual (data-manual="true" on tr)
  for(let i=0;i<rows.length;i++){
    const cur = rows[i], prev = i>0?rows[i-1]:null;
    const tr = cur.tr;
    const diffCell = tr.querySelector('.diff');
    const pctCell = tr.querySelector('.pct');
    if(prev && cur.value!=null && prev.value!=null){
      const diff = cur.value - prev.value;
      const pct = prev.value !== 0 ? (diff/Math.abs(prev.value))*100 : null;
      if(tr.dataset.manual !== 'true'){
        diffCell.innerText = fmtNum(diff);
        pctCell.innerText = pct===null? '-' : pct.toFixed(2) + '%';
      }
    } else {
      if(tr.dataset.manual !== 'true'){
        diffCell.innerText = '-';
        pctCell.innerText = '-';
      }
    }
  }

  // update chart (use displayed value)
  const labels = rows.map(r=>String(r.year));
  const data = rows.map(r=> r.value===null?NaN:r.value);
  if(chart) chart.destroy();
  chart = new Chart(chartCanvas.getContext('2d'), {
    type: 'line',
    data: { labels, datasets:[{ label:'Value', data, borderColor:'rgba(99,102,241,1)', backgroundColor:'rgba(99,102,241,0.12)', fill:true, tension:0.25 }] },
    options: { responsive:true, plugins:{legend:{display:false}} }
  });
}

/* Generate button handler unchanged except computeYoY now returns count */
generateBtn.addEventListener('click', ()=>{
  const from = parseInt(yearFrom.value,10), to = parseInt(yearTo.value,10);
  if(isNaN(from) || isNaN(to) || from>to){ alert("Invalid year range"); return; }
  const agg = aggMode.value;
  const results = computeYoY(from, to, periodMode.value, agg);
  renderResults(results);
});

/* download chart PNG */
downloadChartPng.addEventListener('click', ()=>{
  if(!chart){ alert("No chart"); return; }
  try { const url = chart.toBase64Image(); const a = document.createElement('a'); a.href = url; a.download = "combined_yoy_chart.png"; document.body.appendChild(a); a.click(); a.remove(); } catch(e){ alert("Failed to export chart PNG"); }
});

/* export current table rows */
exportCsvBtn.addEventListener('click', ()=>{
  const trs = Array.from(resultTbody.querySelectorAll('tr'));
  if(!trs.length){ alert('No results to export'); return; }
  const rows = [['Year','Value','Count','Diff','Pct']];
  trs.forEach(tr=>{
    const year = tr.querySelector('.year').innerText.trim();
    const val = tr.querySelector('.value').innerText.trim();
    const cnt = tr.querySelector('.count').innerText.trim();
    const diff = tr.querySelector('.diff').innerText.trim();
    const pct = tr.querySelector('.pct').innerText.trim();
    rows.push([year, val, cnt, diff, pct]);
  });
  const csv = rows.map(r=> r.join(',')).join('\n');
  const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([csv],{type:'text/csv'})); a.download = 'yoy_results_export.csv'; document.body.appendChild(a); a.click(); a.remove();
});

/* Save Table CSV explicit */
saveTableCsv.addEventListener('click', ()=>{
  const trs = Array.from(resultTbody.querySelectorAll('tr'));
  if(!trs.length){ alert('No rows to save'); return; }
  recalcFromTable();
  const rows = [['Year','Value','Count','Diff','Pct']];
  trs.forEach(tr=>{
    const year = tr.querySelector('.year').innerText.trim();
    const val = tr.querySelector('.value').innerText.trim();
    const cnt = tr.querySelector('.count').innerText.trim();
    const diff = tr.querySelector('.diff').innerText.trim();
    const pct = tr.querySelector('.pct').innerText.trim();
    rows.push([year, val, cnt, diff, pct]);
  });
  const csv = rows.map(r=> r.join(',')).join('\n');
  const ts = new Date().toISOString().replace(/[:\-]/g,'').split('.')[0];
  const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([csv],{type:'text/csv'})); a.download = `yoy_results_saved_${ts}.csv`; document.body.appendChild(a); a.click(); a.remove();
});
</script>
</body>
</html>
